<<深入理解Java虚拟机>>笔记

##### Java内存区域

Java虚拟机在运行Java程序的将所管理的内存分为以下几个数据区域
- 方法区
- 堆
- 虚拟机栈
- 本地方法栈
- 程序计数器

其中方法区和堆栈是有所有线程共享，而虚拟机栈，本地方法栈，程序计数器是线程私有的数据去

![JVM runtime data area](image/jvm-runtime-data-area.jpg)



###### 程序计数器(PC)
在线程启动的时候创建，大小是一个字长。如果线程正在执行Java方法，计数器记录保存的是下一个将要执行的
指令“地址”。如果线程正在执行本地方法，则保存的值为Undefined

###### Java虚拟机栈
JVM Stack是线程私有的，和线程有相同的生命周期。每个方法在执行是会创建一个栈帧,来存储局部变量表，操
作数栈，动态连接，方法出口等信息。 局部变量表存储了编译期可知的基本数据类型，引用类型和returnAddress类型。局部变量表所需内存空间在编译时已经确定。

如果线程请求的栈空间大于虚拟机允许的最大值，会抛出StackOverflowError。如果JVM stacksh是可以动态
扩展的，但是最后内存还是不够，则会抛出OutOfMemoryError。

![JVM Stack](image/jvm-stack.jpg)


###### 本地方法栈
本地方法栈和虚拟机方法栈类似，只不过虚拟机方法栈是为执行Java方法服务，而本地方法栈则是为执行本地方法服务。本地方法栈也可能会抛出StackOverflowError和OutOfMemoryError.

###### 堆
Java堆是所有线程共享的一块内存区域。所有的对象实例和数据都要在堆上分配。堆是垃圾回收器管理的主要区域。
可以通过-Xms和－Xmx来设置堆的初始大小和最大大小。

###### 方法区

方法区是所有线程共享的内存区域。用于存储虚拟机加载的类，常量，静态变量等数据。又被叫做Non-Heap(非堆)
当方法区无法满足内存分配需求时会抛出OutOfMemoryError。

###### 运行时常量池
运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件除了有类的版本，字段，方法，接口等信息， 还有一项是常量池，用来存放编译时生成的字面量和符号引用，这部分内存在类加载后会进入运行时常量池。 运行时常量池相对于类文件的常量池还具备动态性，在运行期间可以将新的常量放入池中。比如String类的intern()。 当常量池无法在申请到内存时也会抛出OutOfMemoryError。

###### 直接内存
直接内存(Direct Memory)是Java 1.4中加入的NIO使用本地函数库直接分配堆外内存，通过存储在堆中的DirectByteBuffer对象作为这块内存的引用。直接内存不受Java堆大小的限制。


###### 对象的创建
在分配内存空间的时候，如果堆中的内存是规整的，可以用指针碰撞的方法，否者就要使用空闲列表的方法。
这也取决于垃圾回收是否会整理内存。

![Process of new java object](image/process-of-new-object.jpg)

###### 对象的内存布局
对象在内存中的存储可以分为如下图所示的几个区域，对象头，实例数据和对齐填充。

![Object Memory Model](image/object-memory-model.jpg)
- 对象头 对象头包括两部分信息
  - 第一部分来存储对象自身的运行时数据，如哈希值，GC分代年龄，锁状态，线程持有的锁等。在32/64位虚拟机上也是对应的32/64位。出于对虚拟机空间效率的考虑，对象头被设计成非固定数据结构以便在极小的空间尽可能多的存储信息。
  - 第二部分是类型指针，指向它的类的元数据
  另外如果对象是数组，对象头中还有一块来记录数组的长度
- 实例数据 在相同宽度的字段会被分配到一起的前提下，父类中定义的字段会出现在子类之前。
- 对齐填充 因为Hotspot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍。所以对象的大小也就是8字节的整数倍。当实例数据没有对齐时，就需要对齐填充来补全。

######对象定位
在建立对象后，Java程序需要使用栈帧中的reference来访问堆上堆具体对象。目前流行的方法方式有句柄和直接指针

![Object Access](image/object-access.jpg)

句柄访问的优点是在对象被移动时，只需要改动句柄中的对象实例数据指针。直接指针访问的好处时速度快。



#### 垃圾回收
在程序计数器，虚拟机栈和本地方法栈会随着线程而生，随线程而灭。栈中的栈帧会随着方法的进入和退出执行进栈
和出栈操作，每一帧中分配多少内存在类结构确定下来的时候是已知的，所以在这几个区域在方法结束或者线程结束的时候，内存自然就随着回收了，所以这几个区不需要过多的考虑内存回收的问题。而Java堆区和方法区则不一样，一个接口的多个实现可能需要的内存不一样，我们也只有在程序运行期间才知道需要创建哪些对象，所以这部分的内存是需要动态的分配和回收的。而垃圾回收所关注也是这部分内存。

在堆中存放着Java世界中几乎所有的对象，垃圾回收器在进行回收前，需要判断哪些对象还"活着"，哪些已经"死去"
###### 引用计数算法
引用技术算法(Reference Counting)就是给对象添加一个引用计数器，每当一个地方引用它时，计数器就加1，当引用失效时，计数器就减1.当计数器的值为0时表示对象不再被使用。

但是简单的引用计数器算法很难解决对象间相互引用的问题。

![Reference Cycle](image/reference-each-other.jpg)


###### 可达分析算法
可达分析(Reachability Analysis) 是来分析对象是否存活的主流实现。算法的基本思路就是通过一系列的
被成为"GC Roots"的对象作为起始点，从这鞋节点开始向下搜索，搜索所走过的路径被成为引用链(ReferenceChain)，
如果以个对象到GC Roots没有任何引用链相连，则证明此对象不可用。

![Reachability Analysis](image/reachability-analysis.jpg)

在JVM中可以作为GC Roots的对象包括下面几种
- 虚拟机栈中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象


要宣告一个对象的死亡，至少会经过两次标记过程。在进行可达分析后，如果对象不在引用链中，它将会被第一次标记并且进行一次筛选，
筛选的条件就是该对象是否有必要执行finalize方法。如果该对象没有覆盖finalize方法，或者已经执行过finalize方法，则被视为没必要执行。
如果时有必要执行，则将该对象放入一个叫做F-Queue的队列中，并在稍后由虚拟机启动一个低优先级的Finalizer线程来执行finalized方法。但是这个线程并不保证会等待finalize()运行结束。因为如果finalize()方法执行缓慢或者死循环，将可能导致F-Queue队列中的其他对象处于永久等待的状态，从而导致整个内存回收系统的崩溃状态。稍后垃圾回收器会对F-Queue中的对象进行二次标记，如果对象没有finalize方法中逃脱，则基本上就被回收了。
如果没必要执行，垃圾回收器则对对象进行回收。

###### 引用

无论是引用计数还是可达分析都是通过引用来判断对象是否存活。在JDK1.2之前，引用的定义就是传统意义上的引用。如果reference
类型的数据中存储的是另一块内存的起始地之，我们称之为引用。 这种定义使对象只有引用和没有引用两种状态。

JDK1.2中对引用进行了扩充，将引用分为:
- 强引用(String Reference)
- 软引用(Soft Reference)
- 弱引用(Weak Reference)
- 虚引用(Phantom Reference)

强引用是在代码中普遍存在的引用，比如Object obj = new Object()；对于这类的对象，只要强引用还在，垃圾回收器就不会回收
被引用的对象

软引用是用来描述一些还有用但是并非必须的对象。对于被软引用引用的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围
并进行二次回收，如果在回收之后还是不能满足要求，才抛出内存溢出异常。在JDK1.2中提供了SoftReference来实现软引用。

弱引用也是用来描述非必需对象的。只是它比软引用更弱一些，被弱引用引用的对象只能生存到下次垃圾回收发生之前。在垃圾回收进行时，
不管内存是否足够，都会回收掉只有弱引用引用的对象。在JDK1.2之后，提供了WeakReference来实现弱引用。

虚引用也称为幻影引用或者幽灵引用，它是最弱的一种引用。一个对象是否有虚引用的存在，完全不影响它的生存时间。也无法通过一个虚引用
来获取一个对象实例。为对象设置一个虚引用的唯一作用就是当这个对象被回收时能够收到一个系统通知。在JDK1.2以后，提供了PhantomReference
来实现虚引用。

###### 回收方法区
方法区(HotSpot中的永久代)的垃圾回收主要回收两部分内容，废弃常量和无用的类。

判断一个类是否无用，需要满足下面的三个条件：
- 该类所有的实例都被回收
- 加载该类的ClassLoader已被回收
- 该类对应的Class对象没有在任何地方被引用。

虚拟机可以对满足这三个条件的类进行回收，但是它不像对象，不用了就必然会回收。是否对类进行回收，虚拟机提供了-Xnoclassgc参数来进行控制。还可以使用-verbose:class和-XX:+TraceClassLoading -XX:+TraceClassUnLoading查看类的加载和卸载信息。前两个可以在Product版本的虚拟机中使用，后者需要FastDebug版虚拟机的支持。


###### 标记－清楚算法
最基础的收集算法是标记－清除(Mark-Sweep)算法。算法分为标记和清除两个阶段。首先会标记出所有需要回收的对象，在标记完之后统一
进行回收。标记算法就是前面提到过的引用计数和可达分析。这种算法存在两个不足：
- 效率问题。标记和清楚两个阶段的效率都不高
- 空间问题。在标记清楚后会产生大量不连续的内存碎片，空间碎片太多导致程序需要分配较大的对象而找不大合适的内存空间时，不得不再次触发垃圾回收动作。

![Mark-Sweep](image/mark-sweep.jpg)


###### 复制算法
为了解决标记－清楚的效率问题，一种称为复制算法出现。它将内存按照容量大小分成两块，每次只使用其中的一块。当其中的一块用完了，就将还存活的对象复制到另一块上。再把之前的那块内存一次清理掉。这使得每次都是对内存的整个半区进行内存回收。在内存分配时不需要考虑内存碎片等情况，只要移动堆顶指针，按顺序分配内存即可。但是这种算法的缺点也很明显，它使可用内存比实际内存缩小了一半。

![Copy](image/copy.jpg)

现代的商业虚拟机基本上都采用了这种算法来回收新生代。IBM的专门研究表明，在新生代中的对象98%都是"朝生夕死"，所以不需要按照1:1的比列来划分内存空间。而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor空间。
当需要回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间上，最后清理掉刚才使用过的Eden和Survivor空间HotSpot
中默认的Eden和Survivor的大小比例为8:1, 也就是每次新生代中可用的内存空间为整个新生代内存容量的90%，只有10%的空间会被"浪费"。我们没办法保证每次回收的只有不多余10%的存活对象，当Survivor空间不够用时，需要依赖其他内存(老年代)提供分配担保(Handle Promotion).也就是说如果另外一块Survivor空间如果没有足够的空间来保存上一次新生收集存活下来的对象，这些对象将通过担保机制进入老年代。


###### 标记－整理算法
复制收集算法在对象的存活率较高时需要进行较多的复制操作，效率会比较低。如果不想浪费50%的空间，需要有额外的分配担保。所以在老年代不能直接使用这种算法。而需要另外一种标记－整理(Mark-Compact)算法。标记是和标记－清除一样的。但后续阶段不是直接对标记的对象进行清理,而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

![Mark Compact](image/mark-compact.jpg)


###### 分代收集算法
当前所有的商业虚拟机都采用了分代收集(Generational Collection)算法, 这种算法只是根据对象存活周期的不同，将内存划分成几个
区域。一般把Java堆区分为新生代和老年代，这样就可以根据各个区的特点采用适当的收集算法。

在新生代，每次回收时都会有大量的对象死去，只有少量存活。那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
老年代中因为对象的存活率高，没有额外的空间进行分配担保，就必须使用标记－清理或者标记－整理的算法。


###### HotSpot的算法实现


HotSpot在实现上面的算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机的高效运行。

以可达分析为例，在从GC Roots节点找引用链的过程中，我们知道可以作为GC Roots的节点主要在全局性的引用和执行上下文中，在很多
应用中，仅方法区就很大，如果要逐个检查其中的应用，那是相当耗时的。 可达分析对时间的敏感性还体现在GC停顿上，因为分析工作必须在一个确保一致性的快照里进行。在执行GC期间，虚拟机必须暂停所有的Java执行线程(Stop the world)。

由于主流的虚拟机都是采用准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的去检查所有执行上下文和全局引用的位置。虚拟机应当有办法直接知道哪些地方存放着对象引用。

在HotSpot中，是使用一组被称为OopMap的数据结构来实现这个目的的。在类加载完成后，HotSpot就把对象内什么偏移量上有什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样GC在扫描时就可以得知这些信息了。


在程序执行的过程中，并不是所有的地方都能够停顿下来进行GC,只有在一些特定的位置才能暂停，这些位置被称为安全点(SafePoint)
安全点的位置可以是：
- 方法临返回前／调用方法的call指令后
- 循环的末尾
- 可能抛出异常的位置

安全区域(Safe Region)

安全区域是为了处理一些储蓄不执行状态的时，比如线程处于Sleep或者Blocked状态，这时候时没法响应JVM的中断请求，执行到安全点挂起的。对于这种情况，就需要安全区域来解决。安全区域是指在一段代码片段中引用关系不会发生变化，在这段代码中的任何地方开始GC都是安全的。当线程执行到Safe Region中时，会首先标示自己已经进入Safe Region,那样当在这段时间里JVM要发起GC时，就不用管处于Safe Region的线程了。如果线程在离开Safe Region时，他要检查系统是否已经完成了跟节点的枚举，如果完成则线程就继续执行，如果没有这就需要等待知道收到可以安全离开Safe Region的信号为止。

##### 垃圾收集器
HotSpot虚拟机中包含的垃圾收集器

![HotSpot GC](image/hotspot-gc.jpg)


###### Serial收集器
Serial收集器时最基本，历史最悠久的收集器。他是一个单线程的收集器，只会使用一个收集线程来完成垃圾收集工作。在它进行垃圾收集时
必须暂停其他所有工作的线程，直到它收集结束。

![Serial GC](image/serial-gc.jpg)


###### ParNew收集器
ParNew收集器就是Serial收集器的多线程版本。ParNew除了多线程收集外，其他和Serial相比，并没有太多创新。但是它却是运行在Server模式下虚拟机中首选的新生代收集器，其中一个重要的原因时，除了Serial收集器外，只有它能够与CMS收集器配合工作。

![ParNew](image/parnew.jpg)

##### Parallel Scavenge收集器
Parallel Scanvenge收集器时一个新生代收集器，他也是使用的复制算法。又是并行的多线程收集器。Parallel Scavenge 收集器的关注点和其他收集器不同，CMS等收集器的关注点主要在尽可能的缩短垃圾收集时用户线程的停顿，而Parallel Scavenge的目的是达到一个可控的吞吐量。所谓的吞吐量＝运行用户代码的时间/(运行用户代码的时间＋垃圾回收的时间)

停顿时间越短就越适合与用户交互的程序，良好的响应能够提高用户体验。而高吞吐量则可以高效的利用CPU的时间，尽快的完成程序的运算任务。主要适合后台运算而不需要太多交互的任务。

Parallel Scanvenge提供了两个参数来精确的控制吞吐量。分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMills和直接设置吞吐量大小的-XX:GCTimeRatio.

-XX:MaxGCPauseMills允许的值是大于0的毫秒数。收集器尽可能的保证花费的时间不超过设定值。但是并不是把这个值设置的小一点就能是垃圾回收的速度变得更快。GC的停顿时间缩小吞吐量和新生代的空间换来的。系统会把新生代空间调小一点，这就直接导致垃圾回收会更频繁。停顿时间下降，但是吞吐量也会下降。

-XX:GCTimeRatio参数的值应当是个大于0小于100的整数。是程序运行时间和垃圾回收时间的比率。GC的时间占比为1/(1+N).默认值为99.即1/(1+99)=1%.
由于和吞吐量有密切的关系，所以Parallel Scavenge也被称为吞吐量优先的收集器。
Parallel Scavenge还有一个参数-XX:UseAdaptiveSizePolicy，这是一个开关参数，当这个参数打开时，就不需要手工设置新生代的大小(-Xmn)和Eden和Survivor区的比例，已经晋升老年代对象大小(-XX:PretenureSizeTHreshold)等细节参数了。虚拟机会根据当前系统运行情况收集性能监控信息，动态的调整这鞋参数以提供最合适的停顿时间活着最大的吞吐量。这称为GC自适应调节策略。 如果对参数不太熟悉，
只需要制定-XX:MaxGCPauseMills或者-XX:GCTimeRatio给虚拟机设置一个优化目标，其他参数由虚拟机自定完成。自适应策略也是Parallel Scavenge和ParNew的一个重要区别。
