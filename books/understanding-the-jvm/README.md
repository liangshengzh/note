<<深入理解Java虚拟机>>笔记

##### Java内存区域

Java虚拟机在运行Java程序的将所管理的内存分为以下几个数据区域
- 方法区
- 堆
- 虚拟机栈
- 本地方法栈
- 程序计数器

其中方法区和堆栈是有所有线程共享，而虚拟机栈，本地方法栈，程序计数器是线程私有的数据去

![JVM runtime data area](image/jvm-runtime-data-area.jpg)



###### 程序计数器(PC)
在线程启动的时候创建，大小是一个字长。如果线程正在执行Java方法，计数器记录保存的是下一个将要执行的
指令“地址”。如果线程正在执行本地方法，则保存的值为Undefined

###### Java虚拟机栈
JVM Stack是线程私有的，和线程有相同的生命周期。每个方法在执行是会创建一个栈帧,来存储局部变量表，操
作数栈，动态连接，方法出口等信息。 局部变量表存储了编译期可知的基本数据类型，引用类型和returnAddress类型。局部变量表所需内存空间在编译时已经确定。

如果线程请求的栈空间大于虚拟机允许的最大值，会抛出StackOverflowError。如果JVM stacksh是可以动态
扩展的，但是最后内存还是不够，则会抛出OutOfMemoryError。

![JVM Stack](image/jvm-stack.jpg)


###### 本地方法栈
本地方法栈和虚拟机方法栈类似，只不过虚拟机方法栈是为执行Java方法服务，而本地方法栈则是为执行本地方法服务。本地方法栈也可能会抛出StackOverflowError和OutOfMemoryError.

###### 堆
Java堆是所有线程共享的一块内存区域。所有的对象实例和数据都要在堆上分配。堆是垃圾回收器管理的主要区域。
可以通过-Xms和－Xmx来设置堆的初始大小和最大大小。

###### 方法区

方法区是所有线程共享的内存区域。用于存储虚拟机加载的类，常量，静态变量等数据。又被叫做Non-Heap(非堆)
当方法区无法满足内存分配需求时会抛出OutOfMemoryError。

###### 运行时常量池
运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件除了有类的版本，字段，方法，接口等信息， 还有一项是常量池，用来存放编译时生成的字面量和符号引用，这部分内存在类加载后会进入运行时常量池。 运行时常量池相对于类文件的常量池还具备动态性，在运行期间可以将新的常量放入池中。比如String类的intern()。 当常量池无法在申请到内存时也会抛出OutOfMemoryError。

###### 直接内存
直接内存(Direct Memory)是Java 1.4中加入的NIO使用本地函数库直接分配堆外内存，通过存储在堆中的DirectByteBuffer对象作为这块内存的引用。直接内存不受Java堆大小的限制。


###### 对象的创建
在分配内存空间的时候，如果堆中的内存是规整的，可以用指针碰撞的方法，否者就要使用空闲列表的方法。
这也取决于垃圾回收是否会整理内存。

![Process of new java object](image/process-of-new-object.jpg)

###### 对象的内存布局
对象在内存中的存储可以分为如下图所示的几个区域，对象头，实例数据和对齐填充。

![Object Memory Model](image/object-memory-model.jpg)
- 对象头 对象头包括两部分信息
  - 第一部分来存储对象自身的运行时数据，如哈希值，GC分代年龄，锁状态，线程持有的锁等。在32/64位虚拟机上也是对应的32/64位。出于对虚拟机空间效率的考虑，对象头被设计成非固定数据结构以便在极小的空间尽可能多的存储信息。
  - 第二部分是类型指针，指向它的类的元数据
  另外如果对象是数组，对象头中还有一块来记录数组的长度
- 实例数据 在相同宽度的字段会被分配到一起的前提下，父类中定义的字段会出现在子类之前。
- 对齐填充 因为Hotspot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍。所以对象的大小也就是8字节的整数倍。当实例数据没有对齐时，就需要对齐填充来补全。

######对象定位
在建立对象后，Java程序需要使用栈帧中的reference来访问堆上堆具体对象。目前流行的方法方式有句柄和直接指针

![Object Access](image/object-access.jpg)

句柄访问的优点是在对象被移动时，只需要改动句柄中的对象实例数据指针。直接指针访问的好处时速度快。



#### 垃圾回收
在程序计数器，虚拟机栈和本地方法栈会随着线程而生，随线程而灭。栈中的栈帧会随着方法的进入和退出执行进栈
和出栈操作，每一帧中分配多少内存在类结构确定下来的时候是已知的，所以在这几个区域在方法结束或者线程结束的时候，内存自然就随着回收了，所以这几个区不需要过多的考虑内存回收的问题。而Java堆区和方法区则不一样，一个接口的多个实现可能需要的内存不一样，我们也只有在程序运行期间才知道需要创建哪些对象，所以这部分的内存是需要动态的分配和回收的。而垃圾回收所关注也是这部分内存。

在堆中存放着Java世界中几乎所有的对象，垃圾回收器在进行回收前，需要判断哪些对象还"活着"，哪些已经"死去"
###### 引用计数算法
引用技术算法(Reference Counting)就是给对象添加一个引用计数器，每当一个地方引用它时，计数器就加1，当引用失效时，计数器就减1.当计数器的值为0时表示对象不再被使用。

但是简单的引用计数器算法很难解决对象间相互引用的问题。

![Reference Cycle](image/reference-each-other.jpg)


###### 可达分析算法
可达分析(Reachability Analysis) 是来分析对象是否存活的主流实现。算法的基本思路就是通过一系列的
被成为"GC Roots"的对象作为起始点，从这鞋节点开始向下搜索，搜索所走过的路径被成为引用链(ReferenceChain)，
如果以个对象到GC Roots没有任何引用链相连，则证明此对象不可用。

![Reachability Analysis](image/reachability-analysis.jpg)

在JVM中可以作为GC Roots的对象包括下面几种
- 虚拟机栈中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

###### 引用

无论是引用计数还是可达分析都是通过引用来判断对象是否存活。在JDK1.2之前，引用的定义就是传统意义上的引用。如果reference
类型的数据中存储的是另一块内存的起始地之，我们称之为引用。 这种定义使对象只有引用和没有引用两种状态。

JDK1.2中对引用进行了扩充，将引用分为:
- 强引用(String Reference)
- 软引用(Soft Reference)
- 弱引用(Weak Reference)
- 虚引用(Phantom Reference)

强引用是在代码中普遍存在的引用，比如Object obj = new Object()；对于这类的对象，只要强引用还在，垃圾回收器就不会回收
被引用的对象

软引用是用来描述一些还有用但是并非必须的对象。对于被软引用引用的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围
并进行二次回收，如果在回收之后还是不能满足要求，才抛出内存溢出异常。在JDK1.2中提供了SoftReference来实现软引用。

弱引用也是用来描述非必需对象的。只是它比软引用更弱一些，被弱引用引用的对象只能生存到下次垃圾回收发生之前。在垃圾回收进行时，
不管内存是否足够，都会回收掉只有弱引用引用的对象。在JDK1.2之后，提供了WeakReference来实现弱引用。

虚引用也称为幻影引用或者幽灵引用，它是最弱的一种引用。一个对象是否有虚引用的存在，完全不影响它的生存时间。也无法通过一个虚引用
来获取一个对象实例。为对象设置一个虚引用的唯一作用就是当这个对象被回收时能够收到一个系统通知。在JDK1.2以后，提供了PhantomReference
来实现虚引用。
